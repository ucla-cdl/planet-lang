# Example programs

# Wu et al. UIST 2023

As completed by the authors: 


Testing task-based constraints:
```{r}
e = experiment()
e.add_tasks(c1, c2, e1, e2)
e.add_treatment(ffl, latex)

# default, randomized tasks and conditions
# between participant study by default
e.design_experiment() -> possible groups
# group 1: (c1, ffl), group 2: (c2, ffl), etc...
# group 5: (c1, latex), etc...

# experiment block means is a list of trials
# that each participant sees
# one trial per group... example. 
# block 1: (c1, ff1), (c1, latex)
# block 2: (c1, latex), (c2, ffl)
block_length(e, 4)
# default 1 (see above)

creation = create_group(c1, c2)
editing = create_group(e1, e2)
# constraint: if !(seen(c1) and seen(c2)) then !(e1 or e2)
# also: if len(creation) > 0 then !(e1 or e2)
all(creation).before(editing)
# could also look like 
place_in_order(all(creation), editing)
comes_first(all(creation))

# alternate example:
# constraint: if !(seen(c1) or seen(c2)) then !(e1 or e2)
# alsoL if len()
# this is satisfied once we pick a creation task
creation.before(editing)

# once we pick a creation task, remove this from group 

# could we then also say 
editing.before(creation)



# IDEA
num_in_a_row(group1, 1) / max_in_a_row(group1, 1)
# "push" when we see group one and "pop" when we see group two 
# / counter for every object this constraint is on
# if num_group1 == 1, then c2 or e2
# anything if num_group1 == 1

# to get the paper results with these, we could write: 
order(all(creation), editing)
max_in_a_row(group1, 1)



# then we pass to sat solver with certain constraints

# note: referencing group alone acts as 
# t1 or t2, or ... tn for all tasks in group
# entire(group) means t1 and t2, and ... tn 
# for all tasks in group

# constraint: if !(seen(c1) and seen(c2)) then !(e1 or e2)
e.enforce_order(both(c1, c2), either(e1, e2))
# constraint: if (prev(e1) or prev(e2)) then (e2 or c2)
e.enforce_order(either(e1, c1), either(e2, c2))


```

```{r}
library('exp-des-dsl') # TODO: Come up with a memorable name

exp = Experiment(total_trials = 4) # 4 trials per run of an experiment

# Declare tasks
c1 = task(exp, "c1")
c2 = task(exp, "c2")
e1 = task(exp, "e1")
e2 = task(exp, "e2")

# Declare conditions
ffl = condition(exp, "ffl")
latex = condition(exp, "latex")

# Specify task constraints
sequence_constraint = sequence(exp, list(list(c1, c2), list(e1, e2))) => {} # set of all possible orders
# this would look like 
#{
#    {c1, c2, e1, e2},
#    {c1, c2, e2, e1},
#    {c2, c1, e1, e2},
#    {c2, c1, e2, e1}
#}

group1 = list(c1, e1)
group2 = list(c2, e2)
index_groups = list(group1, group2) # "index"
index_group_order = randomize(index_groups) => list() # with random order of groups
# example: either list(c1, e1), list(c2, e2) OR list(c1, e1), list(c2, e2)
rotatate_constraint = rotate(exp, list(list(c1, e1), list(c2, e2))) => {} # set of all possible orders
# this would look like 
#{
#    {c1, c2, e1, e2},
#    {c1, e2, e1, c2},
#    {c2, c1, e2, e1},
#    {c2, e1, e2, c1},
#    {e1, e2, c1, c2},
#    {e1, c2, c1, c2},
#    {e2, e1, c2, c1},
#    {e2, c1, c2, e1}
#}

possible_orders = intersect(rotate_constraint, sequence_constraint) => {} # set of all possible task orderings
# returns: 
# {c1, c2, e1, e2}
# {c2, c1, e2, e1}

# What if we dont want a random rotation order? 
# ie. c1, c2, e2, e1
# specify order using regex-type syntax
a -> list(c1, e1)
b -> list(c2, e2)

# third param is a regex specifying: 
# at list one of group a, followed by two of group b, followed by at least one of group a
# would need to coordinate with length constraint for this to work 
order_groups(group1, group2, "{a}+{b}{b}{a}+") 

# ALTERNATIVE TO WHAT AUTHORS DID
sequence(exp, List(c1, c2, replace=TRUE/FALSE), list(e1, e2))

# Output
get_possible_conditions(exp) => 
c1 c2 e2 e1
c2 c1 e1 e2
c1 c2 e1 e2
c2 c1 e2 e1

## ALL POSSIBLE
# Default: no repetition, max length of total_trials
get_possible_conditions(exp) => 
entire possible list

# What if I want to enforce repetition?
> TODO: What does the function for this look like?? 
# user must specify 


# setting constraints based on a group label 
c1 = task("c1", type=list("Creation",1))
e1 = task("c1", type=list("Editing",1))
match_index(c1, type = 1, list(e1, e2)) 
# params = (task you want to match, type description you want to match, set you are samplign from)
# output: e1 since e1 is the only element in the list that has an index label of "1"

c1 = task("c1", type=list("Creation",1))
e1 = task("c1", type=list("Editing",1))
e2 = task("e2", type=list("Editing",2))

# Type 1 comes before any other Type
first(1) # 1 is a group label
before(1,2) # assume Type 2 is defined
# output looks like 
# c1, e1, e2
# e1, c1, e2
# because e2 is the only task with a 2 index, and all 1 indexed tasks must come before 2-indexed tasks

# Specify constraints for how tasks are assigned
# Sequence means that the lists must follow the order (i.e., all cs before all es), 
# but the order within each list can vary. 
# By default, order of elements in each list becomes the global order. 
sequence(exp, list(c1, c2), list(e1, e2)) => {}
# Specify that if c1 is first, then e1 must be first
rotate(exp, list(c1, e1), list(c2, e2)) => {}

sequence(exp, sequence(...))

sequence() => {}

sequence(), sequence() => {}`

rotate(exp, list(c1, e1), list(c2, e2), list(c3, e3))

c1, c2, c3, c4, ...


cs always precede es => e cannot be the first task
all cs always preced all es => e cannot be the first or second task
within cs and within es, 



c1 must always be first => always_first(c1) => always_first_in_group(c1, list(cs, es))
c1 comes before all other cs in cs => always_first_in_group(c1, cs)
cs come before es => always_group_is_first(cs, es)

always_first_in_group(c1, list(cs, es))
always_first_in_group(c2, list(cs, es))

always_first(c1)
always_second(c2)



what: if c1 is first in its group, e1 must be first in its group
how: => rotate()

{} \intersect {} \intersect {} \intersect {} => {}


There are two different approaches: 
- logical constraints on different subsets 
- generating and intersecting complete sets





# cs come before es
before(exp, list(c1, c2), list(e1, e2))
# Order between c1 and c2 is randomly picked
cs_order = random(c1, c2)
# Order between e1 and e2 is randomly picked
random(e1, e2)
# If c1 comes first in cs, e1 also comes first in es
random(c1, e1)
random(c2, e2)
apply_order(cs_order, es)



===
before(cs, es)
type_order(1, 2) OR type_order(2, 1) => HOW TO REPRESENT A DISJUNCTION??


# Specify constraints for how conditions are assigned

# Get output tasks and conditions

```

Variation on Wu et al. UIST 2023: 
```{r}
```

# Huh et al. UIST 2023

As complated by the authors: 
```{r}

```



