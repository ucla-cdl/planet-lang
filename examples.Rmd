# Example programs

# Wu et al. UIST 2023

As completed by the authors: 


Testing task-based constraints:
```{r}
e = experiment()
add_tasks(e, list(c1, c2, e1, e2))
add_treatment(e, list(ffl, latex))

# default, randomized tasks and conditions
# between participant study by default
design_experiment(e) -> possible groups
# group 1: (c1, ffl), group 2: (c2, ffl), etc...
# group 5: (c1, latex), etc...

# experiment block means is a list of trials
# that each participant sees
# one trial per group... example. 
# block 1: (c1, ff1), (c1, latex)
# block 2: (c1, latex), (c2, ffl)
block_length(e, 4)
# default 1 (see above)

creation = create_group(c1, c2)
editing = create_group(e1, e2)

# constraint: if !(seen(c1) and seen(c2)) then !(e1 or e2)
# also: if len(creation) > 0 then !(e1 or e2)

# options
pick_in_order(all(creation), editing)
comes_first(all(creation))

# means if we are picking the first or second,
# then pick from creation tasks so if trial_index == 1, 
# so c1 or c2 and not e1 or e2
pick_from(creation, range = 1:2)
# alternate example:
place_before(all(creation), editing)


# alternate constraint: if !(seen(c1) or seen(c2)) then !(e1 or e2)
# this is satisfied once we pick a creation task
place_before(creation, editing)

# IDEA
group1 = list(c1, e1)
group2 = list(c2, e2)
num_in_a_row(group1, 1) / max_in_a_row(group1, 1)
# "push" when we see group one and "pop" when we see group two 
# / counter for every object this constraint is on
# if curr_group1 == 1, then c2 o4rr e2
# now curr_group1  == 0, which means we can pick any task 
# that satisfy other constraints (c1 or c2 or c3 or c4)

# to get the paper results with these, we could write: 
pick_in_order(all(creation), editing)
max_in_a_row(group1, 1)
max_in_a_row(group2, 1)

# then we pass to sat solver with certain constraints

# note: referencing group alone acts as 
# t1 or t2, or ... tn for all tasks in group
# all(group) means t1 and t2, and ... tn 
# for all tasks in group

# constraint: if !(seen(c1) and seen(c2)) then !(e1 or e2)
enforce_order(all(c1, c2), any(e1, e2))
# constraint: if (seen(e1) or seen(e2)) then (e2 or c2)
enforce_order(any(e1, c1), any(e2, c2))

# note: must be able to match length of block
# Testing using regex-like formatting
enforce(pattern("ccee"))
enforce(or(pattern("1212"), pattern("2121")))
# ALSO 
enforce(or(pattern("(12)*"), pattern("(21)*")))
# ALSO 
enforce_one_of(pattern("(12)*"), pattern("(21)*"))
# so then we would randomly pick pattern 1 or pattern 2

# if prev == 1, then pick(2)
#    AND 
# if prev == 2, then pick(1)
#   AND 
# if prev == None, then pick(1 or 2)


```

10/01 notes 
```{r}
block_length(4) -> a block contains a sequence of 4 trials
# additional constraint: blocklength % total_tasks == 0

creation = list(c1, c2)

seg1 = block_segment(0:2)
seg2 = block_segment(2:4)

only(creation, seg1)
# if index >= 1 or idex >= 2, then 
# (c1 or c2)

# maybe this looks a new model to check for 
# sat accross all variables ?
# more expensive + 2 passes...
enforce(at_least_one(group1), seg1)
# (c1 or e1)
enforce(at_least_one(group2), seg1)
# (c2 or e2)

# results in if seg1 then (c1 or e1) and (c2 or e2)
# NO constraints on seg 2 right now 
share_type(block(1), block(3))
share_type(block[2], block[4])

# or?
group1 = (c1 or e1)
group2 = (c2 or e2)
match_order(seg1, seg2, list(group1, group2))



# for conditions, think of as an overlay 
conditions = (ffl, latex)
apply(conditions, seg1)
match_order(seg1, seg2, conditions)
-> {ffl, latex, ffl, latex}
   {latex, ffl, latex, ffl}
# if seg2, then
#     group1 if seg1[i] in group1
#     group if seg1[i] in group1


# example with paper 2: 
block_length(8) -> {one row with 8 conditions}
seg1 = segment_block(0:4) -> first 4 cols
seg2 = segment_block(4:8) -> last 4 cols



interpretation = list(short-base, long-base, short-assist, long-assist)
base = list(short-base, long-base)
assist = list(short-assist, long-assist)

# ???
enforce(all(interpretation), seg1) -> if seg1 then (short or long)
# randomizes interpretation prompts within seg 1
# ie.   shorta, longa, shortb, longb
    #   24 possible options

share_type(block[0], block[1], condition_on = "interpretation")
# if block[0] is base, then block[0] is base


# what if instead:
put_together(base, count = 2)
# then if prev(base) and count < 2 then base

# something to restart replacement ?

# this still works with the other example:
enforce(max_in_a_row(group1))

# something like?
# randomize order of groups with respect to a block segment 
# so this means we "push"/"pop" the model after the segment 
# should we have two models?
random(group1, group2, within=seg1)



# end now we don't need to reason in segments

# hard to enforce a task-level constraint here...
# this is a retrospective constraint


# if pick c1 at index 1, then add not(c1)
# so we have (c1 or e1) and not(c1) = e1
share_type(block(1), block(3))
share_type(block[2], block[4])
if type(block[1]) == group1, then (c1 or e1)
if type(blcok[1]) == group2, then (c2 or e2)
e1 if c1 
e2 if c2
```

```{r}
library('exp-des-dsl') # TODO: Come up with a memorable name

exp = Experiment(total_trials = 4) # 4 trials per run of an experiment

# Declare tasks
c1 = task(exp, "c1")
c2 = task(exp, "c2")
e1 = task(exp, "e1")
e2 = task(exp, "e2")

# Declare conditions
ffl = condition(exp, "ffl")
latex = condition(exp, "latex")

# Specify task constraints
sequence_constraint = sequence(exp, list(list(c1, c2), list(e1, e2))) => {} # set of all possible orders
# this would look like 
#{
#    {c1, c2, e1, e2},
#    {c1, c2, e2, e1},
#    {c2, c1, e1, e2},
#    {c2, c1, e2, e1}
#}

group1 = list(c1, e1)
group2 = list(c2, e2)
index_groups = list(group1, group2) # "index"
index_group_order = randomize(index_groups) => list() # with random order of groups
# example: either list(c1, e1), list(c2, e2) OR list(c1, e1), list(c2, e2)
rotatate_constraint = rotate(exp, list(list(c1, e1), list(c2, e2))) => {} # set of all possible orders
# this would look like 
#{
#    {c1, c2, e1, e2},
#    {c1, e2, e1, c2},
#    {c2, c1, e2, e1},
#    {c2, e1, e2, c1},
#    {e1, e2, c1, c2},
#    {e1, c2, c1, c2},
#    {e2, e1, c2, c1},
#    {e2, c1, c2, e1}
#}

possible_orders = intersect(rotate_constraint, sequence_constraint) => {} # set of all possible task orderings
# returns: 
# {c1, c2, e1, e2}
# {c2, c1, e2, e1}

# What if we dont want a random rotation order? 
# ie. c1, c2, e2, e1
# specify order using regex-type syntax
a -> list(c1, e1)
b -> list(c2, e2)

# third param is a regex specifying: 
# at list one of group a, followed by two of group b, followed by at least one of group a
# would need to coordinate with length constraint for this to work 
order_groups(group1, group2, "{a}+{b}{b}{a}+") 

# ALTERNATIVE TO WHAT AUTHORS DID
sequence(exp, List(c1, c2, replace=TRUE/FALSE), list(e1, e2))

# Output
get_possible_conditions(exp) => 
c1 c2 e2 e1
c2 c1 e1 e2
c1 c2 e1 e2
c2 c1 e2 e1

## ALL POSSIBLE
# Default: no repetition, max length of total_trials
get_possible_conditions(exp) => 
entire possible list

# What if I want to enforce repetition?
> TODO: What does the function for this look like?? 
# user must specify 


# setting constraints based on a group label 
c1 = task("c1", type=list("Creation",1))
e1 = task("c1", type=list("Editing",1))
match_index(c1, type = 1, list(e1, e2)) 
# params = (task you want to match, type description you want to match, set you are samplign from)
# output: e1 since e1 is the only element in the list that has an index label of "1"

c1 = task("c1", type=list("Creation",1))
e1 = task("c1", type=list("Editing",1))
e2 = task("e2", type=list("Editing",2))

# Type 1 comes before any other Type
first(1) # 1 is a group label
before(1,2) # assume Type 2 is defined
# output looks like 
# c1, e1, e2
# e1, c1, e2
# because e2 is the only task with a 2 index, and all 1 indexed tasks must come before 2-indexed tasks

# Specify constraints for how tasks are assigned
# Sequence means that the lists must follow the order (i.e., all cs before all es), 
# but the order within each list can vary. 
# By default, order of elements in each list becomes the global order. 
sequence(exp, list(c1, c2), list(e1, e2)) => {}
# Specify that if c1 is first, then e1 must be first
rotate(exp, list(c1, e1), list(c2, e2)) => {}

sequence(exp, sequence(...))

sequence() => {}

sequence(), sequence() => {}`

rotate(exp, list(c1, e1), list(c2, e2), list(c3, e3))

c1, c2, c3, c4, ...


cs always precede es => e cannot be the first task
all cs always preced all es => e cannot be the first or second task
within cs and within es, 



c1 must always be first => always_first(c1) => always_first_in_group(c1, list(cs, es))
c1 comes before all other cs in cs => always_first_in_group(c1, cs)
cs come before es => always_group_is_first(cs, es)

always_first_in_group(c1, list(cs, es))
always_first_in_group(c2, list(cs, es))

always_first(c1)
always_second(c2)



what: if c1 is first in its group, e1 must be first in its group
how: => rotate()

{} \intersect {} \intersect {} \intersect {} => {}


There are two different approaches: 
- logical constraints on different subsets 
- generating and intersecting complete sets





# cs come before es
before(exp, list(c1, c2), list(e1, e2))
# Order between c1 and c2 is randomly picked
cs_order = random(c1, c2)
# Order between e1 and e2 is randomly picked
random(e1, e2)
# If c1 comes first in cs, e1 also comes first in es
random(c1, e1)
random(c2, e2)
apply_order(cs_order, es)



===
before(cs, es)
type_order(1, 2) OR type_order(2, 1) => HOW TO REPRESENT A DISJUNCTION??


# Specify constraints for how conditions are assigned

# Get output tasks and conditions

```

Variation on Wu et al. UIST 2023: 
```{r}
```

# Huh et al. UIST 2023

As complated by the authors: 
```{r}

```



