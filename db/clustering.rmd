
## Clusters Based on Real-World Attributes
### assign using lamba function based on Attributes

### Without explicit naming
Cluster takes on name of unit attributes. In this case, infer 2 clusters. It is possible to have uneven group sizes
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
hospital_membership = variable("hospital_membership", ["hospital1", "hospital2"])

units = units(24).add_attribute(hospital_membership)

clusters = (
        clusters()
        .group_by(hospital_membership) # infers num clusters
        .assign(units)
)       

design = (
   design(exp)
    .assign_to(clusters) 
    .between_subjects(treatment)
)

exp.assign()
```

## Class Inheritance 
User can define their own constraint. Need to add something like a group as attribute function. Should we support the shared members function? Add a ForAll Wrapper?

We probably don't need to overload an assignment function, but rather constraints on assignment. The only alternative is Quasi-Experimental design. 

```python

class FancyClusters(Clusters):
    def never_occur_together(self):
        for m1 in self.members:
            for m2 in self.members:
                if m1 != m2:
                    self.assertions.add(
                        shared_members(
                            m1.get_attribute(clusters), 
                            m2.get_attribute(clusters)
                        ) == 1
                    )
```

```python

class FancyClusters(Clusters):
    def never_occur_together(self):
        # wrapper that performs something for every member
        forall(
            [m1, m2],
            self.assertions.add(
                shared_members(
                    m1.get_attribute(clusters), 
                    m2.get_attribute(clusters)
                ) == 1
            )
        )
        return self
              
```

### Applying the user-defined method
```python
units = units(24)

cluters = (
    clusters()
    .assign(units)
    .num_clusters(4)
    .never_occur_together(units) # NOTE
)
```



# Cluster Assignment in Experimental Design
### Three examples so far 
1. The chronotype paper (dynamic groups)
2. Co-design paper clustering by availability
3. Simple clustering based on one attribute


# Co-Design paper
### Clustering Description
"We opted for groups of three, which led to seven groups in total. Given the challenges of recruiting and scheduling a multi-session study, we formed the groups based on participantsâ€™ availability. If participants disclosed existing relationships (e.g., siblings, friends, classmates), we kept them in the same group since they contacted us at the same time."

Note: family relationship seems like a consequence of availability
Idea: Identify groups defined by overlapping availability
```groupby(availability)```

Lambda function works at individual level makes it difficult to reason about the result of all groups
For groups, randomly with assertion that participants can only be grouped with participants availabile at the same time


### Program Idea (Does not work)
This does not work because it would place everyone with an exact overlap in 
```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "independent"])
t
availability = variable("availability", Range(0, 24)) # 24 hours in a day

units = units(24).add_attribute(treatment)

# clusters = (
#         fancy_clusters()
#         .num_clusters(n=6)
#         .assign(units)
# )       

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```

```
class FancyClusters(Clusters):
    def assign(self, units):
        # select 3 units if all 3 units have overlapping availability
    
    def availabile_at_same_time(self, units):
        self.assertions.add(overlaps(unit1.availability, unit2.availability) for unit1 in self.units for unit2 in self.units)
```


# Chronotype paper
" All participants solved all 24 problems (see Appendix A) and worked
in a group in the morning and with another, different group in the afternoon. Participants never
worked with the same person in a group twice."
" Groups consisted of either two or three individuals who were either heterogeneous or homogeneous in chronotype. "

Two different approaches: 
1. randomly assign participants to groups, then derive group attributes
example: assign p1 and p2 to group 1. p1 and p2 both have morning chronotypes, so the group has a majority morning chronotype attribite.
2. create groups, then assign participants with constraints 
example: group 1 is majority night chronotype group. Then, we can only select from participants who have a night chronotype.

question: what is the purpose of assigning participants in this way? Maybe user passes pre-constructed groups? This wouldn't allow for in depth analysis though

# Simple Clustering
### using groupby
```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "individual"])
university = variable("university", ["UCLA", "MIT"])

units = units(24).add_attribute(university)

clusters = (
        clusters()
        .num_clusters(len(university))
        .group_by(university)
        .assign(units)
)       

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```

### using lambda
```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "individual"])
university = variable("university", ["UCLA", "MIT"])

units = units(24).add_attribute(university)

clusters = (
        clusters()
        .num_clusters(len(university)) # redundant
        .cluster_names(["MIT", "UCLA"])
        .assign(units, clustering_method=lambda x: "MIT" if x.has_attribute("MIT") else "UCLA")
)       

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```

### Mapping
Map keys are the unit attributes, values are list of all possible clusters. If there are more than 1 cluster as a value, then random select one from the list. 
```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "individual"])
university = variable("university", ["UCLA", "MIT"])

units = units(24).add_attribute(university)

clusters = (
        clusters()
        .num_clusters(len(university)) # redundant
        .cluster_names(["MIT", "UCLA"])
        .assign(units, assignment_map={"MIT":["MIT"], "UCLA":["UCLA"]})
)       

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```


### Compose Clusters
Map keys are the unit attributes, values are list of all possible clusters. If there are more than 1 cluster as a value, then random select one from the list. 
```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "individual"])
university = variable("university", ["UCLA", "MIT"])

units = units(24).add_attribute(university)

mit_cluster = (
        cluster()
        .name("MIT")
        .assign(units.with_attribute("MIT"))
)    

ucla_cluster = (
        cluster()
        .name("UCLA")
        .assign(units.with_attribute("UCLA"))
)    

clusters = mit_cluster + ucla_cluster

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```


Maybe we should use assertions instead of lambda functions

```python
exp = Experiment()
treatment = variable("treatment", ["co-work", "individual"])

morning_clusters = (
        clusters()
        .num_clusters(6)
        .assign(units)
) 

group = morning_clusters.as_attribute()
units.add_attribute(group)

night_clusters = (
        clusters()
        .num_clusters(6)
        .assign(units)
        .assertion(len(intersect(unit1.group, unit2.group)) == 0 for unit1 in self for unit2 in self)
)   

clusters = morning_clusters + night_clusters

design = (
   design(exp)
    .assign_to(clusters, method=random()) 
    .between_subjects(treatment)
)

exp.assign()
```

.if(units.attribute == "MIT").then(pick_from(["MIT"]))
.counterbalance(composition)


# like assertion but users can define their own constraints
.no_shared_members(forall(group.units))
class FancyClusters(Clusters):
    def shared_members(self)

    def no_shared_members(self):



class QuasiExperimentalDesign(Design):
    def assign(self):
        if units.has_attribute("mit"):
            units.treatment == "mit"
        elif units.has_attribute("ucla"):
            units.treatment == "ucla"
        else:
            Design.assign() # random!




