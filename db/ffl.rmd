
# Decomposing the FFL Problem

## Cross
This works because we are defining a specific counterbalancing instance where we only include orders when the individual variables are counterbalanced rather than the variable interactions. 
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

design = (
    design(exp, method=random()) 
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task), n = 2) # unit observed under two trials
    .counterbalance(treatment) # counterbalance treatment independent of task so the user always sees 1 then 2 or 2 then 1
    .counterbalance(task) # counterbalance task independent of treatment so the user always sees  then 2 or 2 then 1
)

exp.assign()
```
|1|2|
| ---  | --- |
| drug-walk | placebo-run |
| drug-run | placebo-walk |
| placebo-walk | drug-run |
| placebo-run | drug-walk |

### Compare to full counterbalancing
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

design = (
    design(exp, method=random()) 
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task), n = 2) # unit observed under two trials
    .counterbalance(cross(treatment, task)) 
)

exp.assign()
```
|1|2|
| ---  | --- |
| drug-walk | drug-run |
| drug-run | drug-walk |
| placebo-walk | placebo-run |
| placebo-run | placebo-walk |
| drug-walk | placebo-run |
| drug-run | placebo-walk |
| placebo-walk | drug-run |
| placebo-run | drug-walk |
| placebo-walk | drug-walk |
| drug-walk | placebo-walk |
| placebo-run | drug-run | 
| drug-run | placebo-run | 

### Reasoning
drug-run != drug-walk, but drug == drug, so the combination of variables in counterbalanced but the individual variables are not. 

## Alternative: exposing cross + composition
benefit is that we do not need to make explicit that we observe the unit under two trials. Cross is a merge strategy of two designs. More straitforward but requires detailed understanding about what cross does. 

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

design = (
    design(exp, method=random()) 
    .assign_to(units, method = random())
    .within_subjects(treatment) # unit observed under two trials
    .counterbalance(treatment) # counterbalance treatment independent of task so the user always sees 1 then 2 or 2 then 1
)

design = (
    design(exp, method=random()) 
    .assign_to(units, method = random())
    .within_subjects(task) # unit observed under two trials
    .counterbalance(task) # counterbalance treatment independent of task so the user always sees 1 then 2 or 2 then 1
)

design = cross(treatment_design, task_design)

exp.assign()
```

### Exposing cross as a method
Basically, makes the "merging technique" explicit. 
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

nested_design = (
    design(exp, method=random()) 
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task), n = 2) # unit observed under two trials
    .counterbalance(treatment) # counterbalance treatment independent of task so the user always sees 1 then 2 or 2 then 1
    .counterbalance(task) # counterbalance task independent of treatment so the user always sees  then 2 or 2 then 1
    .cross(treatment, task)
)

exp.assign()
```

### Relating to the cross building-blocks

```python
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])
participants = units(24)

task_plans = no_repeat(pick_n(2, task)) # within subject
treatment_plans = no_repeat(pick_n(2, treatment))

task_treatment_plans = cross(treatment_plans, task_plans) # mixed design

assign(participants, task_treatment_order)
```
|1 | 2 |
| ---  | --- |
| drug-walk | placebo-run |
| drug-run | placebo-walk |
| placebo-walk | drug-run |
| placebo-run | drug-walk |






## Nesting 

### Nesting two independent designs
Express merging strategy and preserve structure of independent designs

```python
exp = Experiment()
task = variable("task", ["creation", "editing"])
interface = variable("interface", ["ffl", "latex"])

units = units(24)

task_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects(task) # unit sees two different values of task variable
    .counterbalance(task) 
)

interface_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method=random())
    .within_subjects(interface) # unit sees two different values of task variable
    .counterbalance(interface) 
)

design = nest(outer=task_design, inner=interface_design)

exp.assign()
```

### Using nest as a property of a single multi-variate design

First, declare multi-variate, within-subjects study, meaning that each unit sees each of the four possible value combinations. Counterbalancing treatment and task indipendently has a different effect from counterbalancing the interaction. This is a softer constraint than fully counterbalancing the interaction because the combination of values does not need to occur the same number of times at each time and for each unit group. 

This may be confusing because counterbalance is closely related to the task variable, rather than the design as a whole. 

Nest is like specifying a merging strategy

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .counterbalance(treatment) 
    .counterbalance(task)
    .nest(inner=treatment, outer=task)
)

exp.assign()
```


### Replications and counterbalancing windows
Setting an interval means that you counterbalance the input variable for every sliding window in the design, and keep the same order for each window. For example, with 4 trials and an interval of 2, we get 1 2 1 2, or 2 1 2 1. Caveat: this is a very specific default behavior...

Replication means that you see n of the same value in a row. 

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .counterbalance(treatment) 
    .counterbalance(task)
    .replicate(treatment, 2)
    .set_interval(task, 2) # counterbalance task independetly for two time intervals (assumes number of times/trials is divisible by 2)
)

exp.assign()
```


### Latin Square with constraints
Notice that nest is a specific instance of a latin square when working with latin squares. We want to counterbalance the combination of all variables, but assert that treatments of same value always appear in pairs of 2. This CAN give the result from the ffl paper, but there is an alternative square
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

clusters = (
    clusters()
    .assign(units)
    .num_clusters(4)
)

# need to assert num groups?

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(clusters, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .counterbalance(cross(treatment, task)) 
    .replicate(treatment, 2) # must see two in a row... could probably change the name
)

exp.assign()
```
### Two possible outputs 
|1|2|3|4|
| ---  | --- | --- | ---|
| a1 | a2 | b1 | b2 | 
| a2 | a1 | b2 | b1 | 
| b2 | b1 | a2 | a1 | 
| b2 | b1 | a2 | a1 | 

|1|2|3|4|
| ---  | --- | --- | ---|
| a1 | a2 | b2 | b1 | 
| a2 | a1 | b1 | b2 | 
| b2 | b1 | a1 | a2 | 
| b1 | b2 | a2 | a1 | 

Why can't we see any other output? Because in order to see every possible condition (ie. counterbalancing), we need to alternate the numbers since treatments (a or b) always occur in pairs of two. Example: if we have a1 a1, then we can never see a2 because the next condition is of type b. There is some assumption here that the carry over effect is the same with respect to the treatment.


### depth
Think of this as sending something forward and backwards. Depth = 2 means something is on the outer layer, and we will multiply this by the number of trials of the other counterbalanced variables. 
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .counterbalance(treatment) 
    .counterbalance(task)
    .set_depth(treatment, 2)
    .set_depth(task, 1)
)

exp.assign()
```


## Can we use blocking to represent this? 

### Block randomization
Group units based on some attribute, perform assignment within these groups, and then merge the groups back together. 

### Idea: can we block on some assigned variable?
Typically, block randomization is based on some attribute inherent in the units (like age). Each unit has exactly one age and cannot belong to any other groups in this case. This way, we can observe an even number of participants with some attribute in each group. Without blocking, we could theoretically assign every young person to palcebo. As a result, we never observe the effect of the drug on any young people.

### Program with Block Randomization with One Between Subjects variable

```python 
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
university = variable("university", ["MIT", "UCLA"])

units = units(24).add_attribute(university)

design = (
    design(exp, method=random()) 
    .assign_to(units)
    .between_subjects(treatment, block_on=university) # first, assign treatments to MIT students. Then, assign treatments to UCLA students
)

exp.run()
```

We can use a similar procedure based on some assigned attribute rather than an attribute that is inherent in a unit. For example, say we assign a task to each unit (creation or editing). Then, block on units how were assigned creation or editing, then assign interface as a within subjects variable. 

```python 
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
university = variable("university", ["MIT", "UCLA"])

units = units(24)

# NOTE: the different here is that we do not know what university a unit attend beforehand.
#   Instead, assign each unit to a university. Then, assign a treatment to people at each 
#   university within their assigned university 
design = (
    design(exp, method=random()) 
    .assign_to(units)
    .between_subjects(university)
    .between_subjects(treatment, block_on=university) # first, assign treatments to MIT students. Then, assign treatments to UCLA students
)

exp.run()
```

If we assign university as a within subjects variable, then every units goes to both UCLA and MIT. However, different units go to the different universities at different time intervals. 

|1|2|
| ---  | --- |
| mit | ucla | 
| ucla | mit |


When we block on university before assigning treatment, we split the table into two:

|1|2|
| ---  | --- |
| mit |    | 
|    | mit |

|1|2|
| ---  | --- |
|  | ucla | 
| ucla |  |

Now, assign a treatments to the units at ucla, ensuring each unit in the block recieves a different treatment. 

|1|2|
| ---  | --- | 
|    | ucla-drug | 
| ucla-placebo | |

Note: the two units are p1 @ ucla and p2 @ ucla


Do the same for the units at MIT

|1|2|
| ---  | --- | 
| mit-drug |  |
|  | mit-placebo | 

Note: the two units are p1 @ mit and p2 @ mit

Sparse table is simply to preserve notion of time from assigning university as a within-subjects variable

merge the tables 

|1|2|
| ---  | --- | 
| mit-drug | ucla-drug |
| ucla-placebo | mit-placebo | 

We can also assign treatments as a within-subjects variable

<style>
    .table {
        width: 30%;
        text-align: center;
    }
    .table {
        background: white;
        color: black;
        word-wrap: break-word;
        text-align: center;
    }
</style>



|1|2|
| ---  | --- |
| mit |    | 
|    | mit |




|1|2|
| ---  | --- |
|  | ucla | 
| ucla |  |


|1|2|3|4|
| ---  | --- | ---  | --- |
| mit-drug |  mit-placebo  |  | |
|  |  | mit-placebo | mit-drug | 

|1|2|
| ---  | --- |
|  |  | ucla-drug | ucla-placebo | 
| ucla-drug | ucla-placebo |  | | 

Resulting table: 

|1|2|3|4|
| ---  | --- |  ---  | --- |
| mit-drug | mit-placebo | ucla-drug | ucla-placebo |   
| ucla-placebo | ucla-drug | mit-placebo | mit-drug | 

Note: do we need to include some assumptions about ordering? this is ok because the groups of units are random. 

Another possible output is when we do not guaruntee order is

|1|2|3|4|
| ---  | --- |  ---  | --- |
| mit-drug | mit-placebo | ucla-placebo | ucla-drug |   
| ucla-drug-placebo | ucla-drug | mit-placebo | mit-drug | 


































### Nested Counterbalancing with Blocking
Why Does this work? Counterbalanced assignment with respect to the treatment. In within subjects, you assign conditions to units at a given state. The groups of participants recieving different sequences are blocks of units, while the groups of participants @ time = t is the group of all participants in one specific state where time = t. In other words, participants at time t = 1 are a different block from participants at time t = 2. We can add more blocks, but it is more difficult to visualize. 

When we block, treat like two different experiments, and then merge. Merge startegy is different depending on whether we see the 

Another difference is that inherent attributes are nested in individuals, while assigned attributes can be crossed accross individuals. 

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

clusters = (
    clusters()
    .assign(units)
    .num_clusters(4)
)

# need to assert num groups?

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(clusters, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .replicate(treatment, 2) # must see two in a row... could probably change the name
    .block_on(treatment)
    .counterbalance(task, block_on=treatment) 
)

exp.assign()
```















## Nest + Cross with three variables

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])
task_number = variable("task", [1, 2])

units = units(24)

nested_design = (
    design(exp, method=random()) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects(cross(treatment, task)) # unit sees every possible combination of the two variables
    .counterbalance(treatment, replications = 2) 
    .counterbalance(task)
    .counterbalance(task_number)
    .counterbalance(cross(task_number, task), window = 2)
)

exp.assign()
```

## FFL paper
```python
exp = Experiment()
task = variable("task", ["creation", "editing"])
number = variable("number", [1, 2])
interface = variable("interface", ["ffl", "latex"])

units = units(24)

nested_design = (
    design(exp, method=random()) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects([number, task, interface], n = 4) # unit sees 4 different combination of the 8 variables
    .counterbalance(task, replications = 2) # counterbalance pairs of the same task value 
    .counterbalance(interface) # interface values occurs equal num times in row and col
    .counterbalance(number) # number values occur equal num times in row and column 
    .start_with(task.condition("creation"))
)

exp.assign()
```

```python
exp = Experiment()
task = variable("task", ["creation", "editing"])
number = variable("number", [1, 2])
interface = variable("interface", ["ffl", "latex"])

units = units(24)

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects([number, task, interface], n = 4) # unit sees every possible combination of the two variables
    .counterbalance(task, depth=exp.outer()) # counterbalance pairs of the same task value 
    .counterbalance(interface, depth = exp.inner()) # interface values occurs equal num times in row and col
    .counterbalance(number, depth = exp.inner()) # number values occur equal num times in row and column 
)

exp.assign()
```

```python
exp = Experiment()
task = variable("task", ["creation", "editing"])
number = variable("number", [1, 2])
interface = variable("interface", ["ffl", "latex"])

creation_task = task.subset(["creation"])
editing_task = task.subset(["editing"])

units = units(24)

creation_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects([number,interface], n = 2) # unit sees every possible combination of the two variables
    .between_subjects(creation_task)
    .counterbalance(interface) # interface values occurs equal num times in row and col
    .counterbalance(number) # number values occur equal num times in row and column 
)

editing_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects([number,interface], n = 2) # unit sees every possible combination of the two variables
    .between_subjects(editing_task)
    .counterbalance(interface) # interface values occurs equal num times in row and col
    .counterbalance(number) # number values occur equal num times in row and column 
)

design = creation_design.then(editing_design) # is the default that the maximum values match?

exp.assign()
```


## messing with cross
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
task = variable("task", ["run", "walk"])

units = units(24)

nested_design = (
    design(exp, method=random()) # implicit creation of new combined conditions
    .assign_to(units, method = random())
    .within_subjects([treatment, task], n = 2) # unit sees every possible combination of the two variables
    .counterbalance(treatment) 
    .counterbalance(task)
    .counterbalance([treatment, task], n = 2)
)

exp.assign()
```


## OLD/testing
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])

units = units(24)

design = (
    design(exp)
    .assign_to(units, method=random())
    .within_subjects(treatment)
    .counterbalance(treatment)
    .counterbalance(Time)
    .counterbalance(units)
    .num_groups(n=len(treatment)) 
)
exp.run()
```

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])

units = units(24)

design = (
    design(exp)
    .assign_to(units, method=random())
    .within_subjects(treatment)
    .counterbalance(treatment)
    .block_on(Time n = len(treatment)) # special type?
    .block_on(units, n = len(treatment))
    .num_groups(n=len(treatment)) 
)
exp.assign()
```

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])

units = units(24)
groups = partition(units, n = len(treatment))

design = (
    design(exp)
    .assign_to(groups, method=random())
    .within_subjects(treatment)
    .counterbalance(treatment)
    .block_on(Time n = len(treatment)) # special type?
    .block_on(groups, n = len(treatment))
)
exp.assign()
```





```python
nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units)
    .within_subjects(cross(task, number, interface)) # unit sees every possible combination of the three variables
    .counterbalance(number, Time[0:2]) 
    .counterbalance(interface, Time[0:2])
    .counterbalance(number, Time[2:4]) 
    .counterbalance(interface Time[2:4])
    .replicate(task, 2)
    .start_with({task:"creation"})
)

exp.assign()
```











## Old Nest Example### Option 1: constructing a design based on another design
Downside here is that there is not clear relationship with a full-counterbalanced design. Pro here is very clear distinction about how the individual variables are counterbalanced.

Another downside of this is that nest is a very visual operation. However, the fluent interface does not expose the matrix or table representation. Everything reasons about properties of variables, so it is not completely clear how two designs nest within each other. 


```python
exp = Experiment()
task = variable("task", ["creation", "editing"])
interface = variable("interface", ["ffl", "latex"])

units = units(24)

design = (
    design(exp) # implicit creation of new combined conditions
    .within_subjects(task) # unit sees two different values of task variable
    .counterbalance(task) 
)

nested_design = (
    design(exp) # implicit creation of new combined conditions
    .assign_to(units, method=random())
    .within_subjects(interface) # unit sees two different values of task variable
    .counterbalance(interface) 
    .nest(design) # applies kronecker product: next design to every value in current design
)

exp.assign()
```