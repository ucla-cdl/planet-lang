# Random Assignment
### Default 
Pure randomization, so an different groups can contain different numbers of units. 
### Counterbalanced randomization
Instead of using a new function, reuse counterbalance function. The definition is the same as within-subjects. However, the between subjects design only has one time/column. The result of using counterbalance with between subjects is an even number of units in each group, where each group is assigned a different treatment conditions


### Regular Between Subjects
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
units = units(24)

design = (
    design(exp)
    .assign_to(units)
    .between_subjects(treatment)
)
exp.run()
```

### One Possible Result
assign 10 units the drug and 14 units the placebo 

### Counterbalanced Between Subjects
```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
units = units(24)

design = (
    design(exp)
    .assign_to(units)
    .between_subjects(treatment)
    .counterbalance()
)
exp.run()
```

### Result
Assign exactly 12 units the drug and exactly 12 units the placebo 

### Subclass of Quasi-Experimental Designs
How can we handle experimental designs where the assigned treatment is some attribute inherent in the unit. 

For example, testing the effect of age on something. We cannot randomly assign age, so our assignment is based on some existing value. 

```python
exp = Experiment()
treatment = variable("treatment", ["drug", "placebo"])
university = variable("university", ["ucla", "mit"])

units = units(24).add_attribute(university)

design = (
    design(exp)
    .assign_to(units)
    .between_subjects(university)
)
exp.run()
```

### Result 
Assign mit to everyone at mit, and assign ucla to everyone at ucla. This way, users do not need to specify a lambda function, which will always have the same structure but varies in regards to the assigned variables that are also attributes. 